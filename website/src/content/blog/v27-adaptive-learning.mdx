---
title: "SuperLocalMemory v2.7: Your AI Learns You — Adaptive Learning with Local ML"
description: "SuperLocalMemory v2.7 introduces adaptive learning with LightGBM ML ranking — all 100% local. Your behavioral data never leaves your machine."
pubDate: 2026-02-16
author: "Varun Pratap Bhardwaj"
tags: ["release", "learning", "privacy", "ml", "gdpr"]
category: "updates"
draft: false
keywords: "SuperLocalMemory v2.7, adaptive learning AI memory, local ML ranking, LightGBM memory, GDPR AI memory, privacy-first AI, personalized AI memory"
image: "/assets/blog/v27-adaptive-learning-hero.svg"
---

import Callout from '../../components/blog/Callout.astro';

## The Problem We Solved

You have been using SuperLocalMemory for three months. You have stored thousands of memories across multiple projects -- architecture decisions, coding patterns, deployment notes, debugging discoveries. The system works. Persistence works. Cross-tool sharing works.

But search is getting noisy.

When you recall "database configuration," you get fifty results. Some are from your current project. Some are from a project you finished six weeks ago. Some are from a quick experiment you abandoned after an hour. The system treats them all equally because, until now, it had no way to know which results matter most to _you_ in _this_ context.

This is the scaling problem every memory system hits. Raw storage and retrieval work fine at low volume. At high volume, you need intelligence -- not just search, but understanding of what is relevant based on how you actually work.

SuperLocalMemory v2.7 solves this with adaptive learning. The system now observes which memories you use, learns your patterns across projects, and re-ranks search results to surface the most relevant content first. All of it runs locally. No cloud. No telemetry. No data leaving your machine.

<Callout type="info" title="What is new in v2.7">

- Three-layer local learning architecture that builds a behavioral model of your workflows
- LightGBM-powered adaptive re-ranking that improves search relevance over time
- Separate `learning.db` database for behavioral data, fully isolated from your memories
- Three new MCP tools: `memory_used`, `get_learned_patterns`, `correct_pattern`
- New CLI commands for inspecting and managing learned patterns
- Synthetic bootstrap that delivers ML-quality results from day one -- no cold-start problem
- Full GDPR compliance with one-command data export and deletion

</Callout>

## How It Works

The v2.7 learning system operates in three layers, each building on the one below it.

### Layer 1: Cross-Project Technology Preferences

The first layer tracks your technology preferences across all projects and profiles. When you consistently choose TypeScript over JavaScript, prefer PostgreSQL over MySQL, or reach for server components over client components, the system records these signals.

These preferences are transferable. Start a new project and your technology affinities carry over. The system does not dictate choices -- it adjusts relevance weights so that memories matching your established preferences rank higher in search results.

### Layer 2: Project Context Detection

The second layer understands project boundaries. It uses four signals -- active directory, recent memory tags, time-of-day patterns, and explicit profile selection -- to determine which project you are working on right now.

This matters because a memory about "API authentication" means something different when you are working on a Node.js backend versus a Python data pipeline. Project context lets the ranker prioritize memories from the relevant project without you having to specify it every time.

### Layer 3: Workflow Pattern Mining

The third layer discovers sequential patterns in how you work. If you consistently recall deployment notes after modifying CI configuration, or if you always check database schema docs before writing migration files, the system learns these sequences.

Over time, it can anticipate what you will need next based on what you just did. This is not prediction in the speculative sense -- it is pattern recognition grounded in your actual recorded behavior.

### Adaptive Re-Ranking with LightGBM

Sitting on top of all three layers is an adaptive re-ranker powered by LightGBM. It takes the raw search results from SuperLocalMemory's existing FTS5 + TF-IDF engine and re-orders them based on everything the learning layers know about you.

The ranker starts with a rule-based system on day one, using synthetic training data bootstrapped from your existing memories. As real behavioral signals accumulate, it transitions smoothly to a full ML model. You never experience a cold-start degradation -- results are personalized from the moment you upgrade.

<Callout type="tip" title="The transition is automatic">

You do not need to configure the learning system or train it manually. Install v2.7, keep using SuperLocalMemory as you normally do, and the system learns in the background. After a few days of use, you will notice search results becoming more relevant to your current context.

</Callout>

## Privacy First

Every byte of behavioral data stays on your machine. This is not a policy decision -- it is an architectural guarantee.

**Separate database.** All learning data lives in `learning.db`, a dedicated SQLite database completely isolated from your memory store (`memory.db`). Your memories and your behavioral patterns are never co-mingled.

**Zero telemetry.** No usage data, no analytics pings, no crash reports, no phone-home of any kind. The learning system has no network code. It cannot send data anywhere because it has no capability to do so.

**GDPR-ready by design.** Export all your behavioral data with a single command. Delete it with another. The separate database makes this trivial -- drop `learning.db` and your behavioral footprint is gone. Your memories remain untouched.

**No cloud dependencies.** The LightGBM model trains locally on your machine. There is no external inference API. The model file lives next to your database, versioned and portable.

Compare this with cloud-based alternatives where your behavioral data -- what you search for, what you use, how you work -- flows through third-party servers. With SuperLocalMemory, that data never leaves your file system.

## Research-Backed Architecture

The v2.7 learning architecture is grounded in published research, adapted for the constraints of a fully local system.

The adaptive re-ranking pipeline draws from eKNOW 2025 work on BM25-to-re-ranker pipelines and ADPMF research on privacy-preserving feedback mechanisms (IPM 2024). The cold-start bootstrap uses techniques from FCS LREC 2024, ensuring ML-quality results before any real behavioral data exists. Workflow pattern mining builds on TSW-PrefixSpan sequence mining (IEEE 2020). The Bayesian confidence scoring extends the MACLA framework (arXiv:2512.18950).

Eight research papers informed the design. The result is an architecture that achieves personalized ranking without any of the cloud infrastructure that existing literature assumes is required.

<Callout type="info" title="A novel contribution">

To our knowledge, SuperLocalMemory v2.7 is the first system to implement fully local, zero-communication, adaptive re-ranking for personal AI memory. Prior work in this space universally assumes cloud-based infrastructure for model training and inference.

</Callout>

## New Tools

### MCP Tools (for IDE integrations)

**`memory_used`** -- The primary feedback channel. When your AI tool uses a recalled memory in its response, it calls `memory_used` to signal that the memory was relevant. This is the strongest learning signal available and it happens automatically through MCP.

**`get_learned_patterns`** -- Retrieve your learned technology preferences, project contexts, and workflow patterns. Useful for inspecting what the system has learned and verifying it matches your expectations.

**`correct_pattern`** -- Override or correct a learned pattern. If the system inferred that you prefer Redux but you have actually switched to Zustand, this tool lets you correct the record. The system adjusts its model accordingly.

### CLI Commands

```bash
# View your learned technology preferences
slm patterns list

# See what the system knows about your current project context
slm patterns context

# Export all behavioral data (GDPR export)
slm learning export

# Delete all behavioral data
slm learning reset

# Check learning system status
slm learning status
```

## Getting Started

Upgrading to v2.7 takes under two minutes.

```bash
# Update to v2.7
npm update -g superlocalmemory

# Verify the version
superlocalmemory --version
# Expected: 2.7.x

# Check that the learning system initialized
slm learning status
```

The learning system activates automatically on first use after upgrade. It creates `learning.db` alongside your existing `memory.db` and begins collecting signals immediately. No configuration required.

Two optional dependencies (`lightgbm` and `scipy`) are installed automatically if you use the npm package. If you installed from source, run:

```bash
pip install -r requirements-learning.txt
```

For the full migration guide, including what changes for existing users and how to verify the upgrade, see the [Upgrading to v2.7](https://github.com/varun369/SuperLocalMemoryV2/wiki/Upgrading-to-v2.7) wiki page.

For a deep dive into the three-layer architecture, visit the [Learning System](https://github.com/varun369/SuperLocalMemoryV2/wiki/Learning-System) documentation or explore the [interactive learning diagram](/learning.html).

<Callout type="warning" title="Backward compatibility">

v2.7 is fully backward compatible. Your existing memories, knowledge graph, patterns, and profiles are untouched. The learning system is additive -- it enhances search results but never modifies your stored data. If the optional ML dependencies are not available, the system falls back to rule-based ranking with no degradation in core functionality.

</Callout>

## What is Next

v2.8 is already in planning. The focus shifts from individual learning to multi-agent collaboration -- enabling multiple AI agents to share context through a single memory layer using the A2A (Agent-to-Agent) protocol. Think of it as giving your entire AI toolkit a shared brain.

More details will be published as the design solidifies. For now, v2.7 makes your personal AI memory meaningfully smarter. Install it, use it for a week, and notice the difference in search relevance.

Your AI is learning you. Locally. Privately. Starting today.
