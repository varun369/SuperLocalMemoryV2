---
title: "How to Give Claude Code Persistent Memory (Free, Local, 5 Minutes)"
description: "Step-by-step guide to adding persistent memory to Claude Code using SuperLocalMemory V2. Free, local-first, works offline. Install in one command."
pubDate: 2026-02-16
author: "Varun Pratap Bhardwaj"
tags: ["claude-code", "memory", "mcp", "tutorial"]
category: "tutorials"
draft: false
keywords: "Claude Code memory, persistent memory Claude Code, Claude Code remember context, MCP memory server Claude"
---

## The Problem: Claude Code Forgets Everything

If you use Claude Code daily, you already know the pain. Every new session starts from a blank slate. Your project architecture, your coding preferences, your naming conventions, the decisions you made yesterday — all gone. You re-explain your codebase structure. You re-state that you prefer TypeScript strict mode. You remind it, again, that your API uses camelCase and your database uses snake_case.

It is like working with a brilliant colleague who has amnesia. The intelligence is there, but the continuity is not. You waste the first five minutes of every session rebuilding context that should already exist. Over a week, that adds up to hours of lost productivity. Over a month, it becomes a serious drag on your workflow.

**Claude Code memory does not have to be this way.** There is a fix — free, local, and installable in under five minutes. No cloud accounts. No subscriptions. No sending your proprietary code to someone else's server.

## What Is SuperLocalMemory V2?

SuperLocalMemory V2 is a free, open-source, local-first AI memory system. It gives any MCP-compatible AI tool — including Claude Code — persistent memory that survives across sessions, restarts, and even machine reboots.

Under the hood, it runs a 10-layer architecture designed for serious engineering workflows. SQLite with FTS5 handles fast full-text search across your stored memories. A knowledge graph with Leiden community detection automatically discovers relationships between concepts you store. Bayesian confidence scoring tracks your coding patterns and preferences over time. An agent trust scoring system manages memory access across different AI tools.

It connects to 17+ AI tools through the Model Context Protocol (MCP): Claude Code, Cursor, Windsurf, VS Code Copilot, ChatGPT Desktop, Codex CLI, Gemini CLI, JetBrains AI, and more. All of them share one local database.

Every byte of data stays on your machine. Zero cloud dependencies. Zero cost. Zero telemetry.

## Prerequisites

You need two things:

- **Node.js 18 or higher.** Check with `node --version`. If you need to install or update, use [nvm](https://github.com/nvm-sh/nvm) or download from [nodejs.org](https://nodejs.org).
- **Claude Code installed and working.** You should be able to run `claude` from your terminal and get a working session.

That is it. No API keys. No cloud accounts. No paid subscriptions. No Docker. No database setup. SuperLocalMemory handles its own storage using embedded SQLite.

## Step 1: Install SuperLocalMemory

Open your terminal and run:

```bash
npm install -g superlocalmemory
```

You should see output similar to:

```bash
added 1 package in 4s

superlocalmemory@2.x.x
```

Verify the installation:

```bash
superlocalmemory --version
```

This single install gives you both the memory system and the MCP server. The MCP server is what Claude Code will communicate with — it exposes memory operations as tools that Claude Code can call directly.

The global install ensures `superlocalmemory` is available from any directory on your machine. If you prefer project-local installs, you can use `npx` instead (covered in the configuration step below).

## Step 2: Configure Claude Code to Use SuperLocalMemory

There are two ways to wire Claude Code memory into your workflow. Use one or both.

### Option A: MCP Server Configuration (Recommended)

Add SuperLocalMemory as an MCP server in your project's Claude Code settings. Create or edit `.claude/settings.json` in your project root:

```json
{
  "mcpServers": {
    "superlocalmemory": {
      "command": "superlocalmemory",
      "args": ["--mcp"]
    }
  }
}
```

Here is what each field does:

- **`mcpServers`** — The top-level key Claude Code reads to discover MCP tool servers.
- **`"superlocalmemory"`** — The name Claude Code will use to identify this server. You can name it anything, but keeping it descriptive helps.
- **`"command"`** — The binary to execute. Since you installed globally, `superlocalmemory` is available on your PATH.
- **`"args": ["--mcp"]`** — Tells SuperLocalMemory to start in MCP server mode, exposing its memory tools over the standard MCP protocol.

If you used a local install instead of global, replace the command with `npx`:

```json
{
  "mcpServers": {
    "superlocalmemory": {
      "command": "npx",
      "args": ["superlocalmemory", "--mcp"]
    }
  }
}
```

### Option B: Add Memory Instructions to CLAUDE.md

For an even smoother experience, add memory usage instructions to your project's `CLAUDE.md` file. This teaches Claude Code *when* to use memory, not just *how*:

```markdown
## Memory

This project uses SuperLocalMemory for persistent context.
- When I share project decisions, architecture choices, or preferences, save them using the remember tool.
- At the start of each session, recall relevant memories about this project.
- Use the forget tool to remove outdated information when I say something has changed.
```

This approach makes Claude Code proactively save and retrieve context without you having to ask every time.

## Step 3: Start Using Memory Commands

Once configured, Claude Code gains three core memory operations. These work as natural language instructions — no special syntax required.

### Remember — Save Context

Tell Claude Code to store something:

```text
Use the remember tool to save: "This project uses React 19 with TypeScript strict mode.
All components use server components by default. Client components are marked explicitly."
```

SuperLocalMemory writes this to your local SQLite database with full-text indexing. The memory is tagged, timestamped, and searchable.

You can store anything: architecture decisions, API conventions, deployment notes, environment quirks, team preferences, debugging findings.

```text
Remember: "The staging database is on port 5433, not the default 5432.
This was changed in January 2026 to avoid conflicts with the local dev database."
```

### Recall — Retrieve Context

Ask Claude Code to search its memory:

```text
Use the recall tool to find memories about database configuration
```

SuperLocalMemory runs a semantic search across all stored memories and returns the most relevant matches. Claude Code receives this context and uses it in its response — seamlessly.

```text
Recall everything you know about our API authentication approach
```

### Forget — Delete Context

Remove outdated or sensitive information:

```text
Use the forget tool to remove memories about the old Stripe API integration
```

This is a hard delete from the SQLite database. Useful for GDPR compliance, rotating credentials references, or clearing stale architectural decisions that no longer apply.

The critical point: **memories persist across all sessions.** Close your terminal. Shut down your machine. Open Claude Code tomorrow, next week, next month. Your context is still there. That is what persistent Claude Code memory means.

## Step 4: Verify It Is Working

Trust but verify. Here is a quick test to confirm persistence:

**1. Save a test memory:**

```text
Remember: "Test memory created on Feb 16, 2026. If you can read this, persistence works."
```

**2. Close your terminal completely.** Not just the Claude Code session — close the entire terminal application.

**3. Open a fresh terminal and start a new Claude Code session.**

**4. Ask Claude Code to recall:**

```text
Recall any test memories from February 2026
```

If it returns your test memory, persistence is confirmed. Your Claude Code memory survives across sessions.

You can also verify by inspecting the database directly. SuperLocalMemory stores everything in a SQLite file at:

```bash
~/.superlocalmemory/memory.db
```

Open it with any SQLite viewer — DB Browser for SQLite, the `sqlite3` CLI, or the SQLite extension in VS Code. You will see your memories stored with full metadata: timestamps, tags, confidence scores, and relationship mappings.

## What Makes This Different From Other Memory Solutions?

The Claude Code memory space has a few options. Here is how they compare:

| Feature | SuperLocalMemory V2 | Mem0 | claude-mem | Manual CLAUDE.md |
|---------|---------------------|------|------------|------------------|
| Price | Free forever | $50/month | Free | Free |
| Data location | 100% local | Cloud | Local | Local |
| Architecture | 10-layer | Graph memory | Key-value | Plain text |
| AI tools supported | 17+ via MCP | API only | Claude only | Claude only |
| Knowledge graph | Yes (Leiden) | Yes | No | No |
| Pattern learning | Yes (Bayesian) | No | No | No |
| Setup time | 5 minutes | 30 minutes | 10 minutes | Manual always |

The biggest differentiator is cross-tool compatibility. SuperLocalMemory is not locked to Claude Code. The same memory database works with Cursor, Windsurf, VS Code Copilot, ChatGPT Desktop, Codex CLI, Gemini CLI, JetBrains AI Assistant, and every other MCP-compatible tool.

Store a memory while using Claude Code. Switch to Cursor for a different task. That memory is available there too. Switch to ChatGPT Desktop for a brainstorming session. Same memories, same context. One local database, accessible from any tool.

Manual CLAUDE.md files work, but they require you to maintain them by hand. They do not scale, they do not search, and they cannot learn patterns. Mem0 offers cloud-based graph memory but costs $50/month and sends your data to external servers — a non-starter for proprietary codebases or enterprise environments.

For a detailed breakdown with benchmark data, see the [full comparison](/comparison).

## Advanced: Knowledge Graph and Pattern Learning

Once you have the basics working, SuperLocalMemory's deeper capabilities activate automatically over time.

The **knowledge graph** discovers relationships between your stored memories using Leiden community detection. If you remember that "Project X uses PostgreSQL" and later remember "PostgreSQL needs connection pooling for Lambda deployments," the graph links these memories. When you recall anything about Project X's database setup, both memories surface together — with the relationship explained.

**Pattern learning** uses Bayesian confidence scoring to track your preferences. As you repeatedly make similar decisions — choosing TypeScript over JavaScript, preferring Zustand over Redux, using server components over client components — SuperLocalMemory builds confidence scores around these patterns. After enough observations, it can surface these preferences proactively when you start a new project.

**Multi-profile support** lets you isolate memories by context. Use `--profile work` for your day job, `--profile personal` for side projects, `--profile client-acme` for a specific client engagement. Each profile maintains its own memory database and knowledge graph.

For a deep dive into the full architecture, visit the [features page](/features).

## Troubleshooting

**"command not found: superlocalmemory"**
Your global npm bin directory is not in your PATH. Run `npm bin -g` to find where npm installed the binary, then add that directory to your shell's PATH in `~/.zshrc` or `~/.bashrc`.

**"MCP server failed to connect"**
Run `superlocalmemory --mcp` manually in your terminal. If it throws an error, the issue is with the installation, not Claude Code. Reinstall with `npm install -g superlocalmemory`.

**Memories not persisting**
Verify the SQLite database exists at `~/.superlocalmemory/memory.db`. If the directory does not exist, SuperLocalMemory may not have write permissions to your home directory.

**Multiple profiles conflicting**
Use explicit profile flags: `superlocalmemory --mcp --profile work`. Update your `.claude/settings.json` args to include the profile flag.

For the full troubleshooting guide and FAQs, see the [documentation](/docs).

## Get Started Now

Persistent Claude Code memory is one command away. No cloud. No cost. No data leaving your machine.

```bash
npm install -g superlocalmemory
```

Five minutes of setup. Every session after that starts with full context — your project architecture, your preferences, your decisions, your debugging notes. All searchable, all persistent, all local.

The source code is open and available on [GitHub](https://github.com/varun369/SuperLocalMemoryV2). File issues there if you hit problems. If SuperLocalMemory saved you time, consider starring the repo — it helps other developers find it.

Your AI never has to forget again.
